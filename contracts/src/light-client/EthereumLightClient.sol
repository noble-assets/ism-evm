// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.30;

import {OwnableUpgradeable} from "@openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol";
import {UUPSUpgradeable} from "@openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin-contracts-upgradeable/utils/PausableUpgradeable.sol";
import {ISP1Verifier} from "succinctlabs-sp1-contracts/src/ISP1Verifier.sol";
import {IEthereumLightClient} from "../interfaces/IEthereumLightClient.sol";

/**
 * @title EthereumLightClient
 * @notice A ZK-verified light client that tracks Ethereum's consensus and execution layer state.
 * @dev This contract maintains finalized beacon block headers, execution state roots, and sync
 *      committee hashes. State transitions are verified using SP1 proofs generated by a Helios
 *      light client circuit, enabling trustless verification of Ethereum state on other chains.
 *
 *      The light client follows Ethereum's sync committee protocol, where committees rotate
 *      every 8192 slots (~27 hours). Each update must chain from a known sync committee to
 *      maintain the security of the verification.
 */
contract EthereumLightClient is OwnableUpgradeable, UUPSUpgradeable, PausableUpgradeable, IEthereumLightClient {
    /// @notice The chain ID of the source Ethereum network being tracked (e.g., 1 for mainnet).
    uint256 public immutable SOURCE_CHAIN_ID;

    /// @notice The duration of a single slot in seconds on the Ethereum beacon chain.
    uint256 public constant SECONDS_PER_SLOT = 12;

    /// @notice The number of slots in a single epoch (32 slots = 6.4 minutes).
    uint256 public constant SLOTS_PER_EPOCH = 32;

    /// @notice The number of slots in a sync committee period (8192 slots = ~27 hours).
    uint256 public constant SLOTS_PER_PERIOD = 8192;

    /// @notice Mapping from beacon chain slot number to the corresponding beacon block header hash.
    /// @dev Only finalized headers verified through valid proofs are stored.
    mapping(uint256 => bytes32) public headers;

    /// @notice Mapping from execution block number to the corresponding state root.
    /// @dev These state roots can be used to verify storage proofs against Ethereum's state.
    mapping(uint256 => bytes32) public stateRoots;

    /// @notice Mapping from sync committee period to the hash of the sync committee for that period.
    /// @dev The sync committee hash is the tree hash root of the committee's public keys.
    mapping(uint256 => bytes32) public syncCommittees;

    /// @notice The latest slot the light client has a finalized header for.
    uint256 public latestSlot;

    /// @notice The latest block number the light client has a finalized execution state root for.
    uint256 public latestBlockNumber;

    /// @notice The verification key for the Helios light client program.
    /// @dev This key is used by the SP1 verifier to validate proofs from the circuit.
    bytes32 public programVk;

    /// @notice The SP1 verifier contract used to verify the proofs.
    ISP1Verifier public verifier;

    /**
     * @notice Constructs the EthereumLightClient implementation contract.
     * @dev Disables initializers to prevent the implementation from being initialized directly.
     *      The contract must be deployed behind a proxy and initialized via the proxy.
     * @param sourceChainId The chain ID of the Ethereum network to track.
     */
    constructor(uint256 sourceChainId) {
        SOURCE_CHAIN_ID = sourceChainId;
        _disableInitializers();
    }

    /**
     * @notice Initializes the light client with a trusted checkpoint.
     * @dev This function can only be called once through the proxy. The initial state must be
     *      obtained from a trusted source (e.g., a checkpoint sync endpoint or manual verification).
     * @param _programVk The verification key for the SP1 Helios circuit.
     * @param initialSlot The beacon chain slot of the initial finalized header.
     * @param initialHeader The beacon block header hash at the initial slot.
     * @param initialStateRoot The execution layer state root at the initial block.
     * @param initialBlockNumber The execution layer block number corresponding to the initial slot.
     * @param initialSyncCommittee The sync committee hash for the period containing the initial slot.
     * @param _verifier The address of the SP1 verifier contract.
     * @param owner The address that will own the contract and have admin privileges.
     */
    function initialize(
        bytes32 _programVk,
        uint256 initialSlot,
        bytes32 initialHeader,
        bytes32 initialStateRoot,
        uint256 initialBlockNumber,
        bytes32 initialSyncCommittee,
        address _verifier,
        address owner
    ) public initializer {
        __Ownable_init(owner);
        __Pausable_init();

        programVk = _programVk;
        require(_verifier != address(0), InvalidAddress());
        verifier = ISP1Verifier(_verifier);

        latestSlot = initialSlot;
        latestBlockNumber = initialBlockNumber;

        headers[initialSlot] = initialHeader;
        stateRoots[initialBlockNumber] = initialStateRoot;
        require(initialSyncCommittee != bytes32(0), InvalidSyncCommittee());
        syncCommittees[getSyncCommitteePeriod(initialSlot)] = initialSyncCommittee;

        emit Updated(initialSlot, initialHeader, initialStateRoot, initialBlockNumber);
    }

    /// @inheritdoc IEthereumLightClient
    function update(bytes calldata proof, bytes calldata publicValues) external whenNotPaused {
        // Verify the proof using the SP1 verifier
        verifier.verifyProof(programVk, publicValues, proof);

        // Decode the public values to extract the CircuitOutput
        CircuitOutput memory output = abi.decode(publicValues, (CircuitOutput));

        // Get previous sync committee
        bytes32 prevSyncCommitteeHash = syncCommittees[getSyncCommitteePeriod(output.prevHead)];
        if (prevSyncCommitteeHash == bytes32(0)) {
            revert InvalidSyncCommittee();
        }

        // Validate previous header and sync committee
        if (headers[output.prevHead] != output.prevHeader) {
            revert InvalidHeader();
        }
        if (prevSyncCommitteeHash != output.prevSyncCommitteeHash) {
            revert InvalidSyncCommittee();
        }

        // Check existing values
        bytes32 existingHeader = headers[output.newHead];
        bytes32 existingStateRoot = stateRoots[output.executionBlockNumber];

        bool headerExists = existingHeader != bytes32(0);
        bool stateRootExists = existingStateRoot != bytes32(0);

        // If either exists, validate they match
        if (headerExists && existingHeader != output.newHeader) {
            revert HeaderAlreadySet();
        }
        if (stateRootExists && existingStateRoot != output.executionStateRoot) {
            revert StateRootAlreadySet();
        }

        // If both exist and match, skip the update
        if (headerExists && stateRootExists) {
            emit UpdateSkipped(output.newHead, output.executionBlockNumber);
            return;
        }

        // Proceed with update
        headers[output.newHead] = output.newHeader;
        stateRoots[output.executionBlockNumber] = output.executionStateRoot;

        // Update latest slot and block number if necessary
        if (output.newHead > latestSlot) {
            latestSlot = output.newHead;
        }
        if (output.executionBlockNumber > latestBlockNumber) {
            latestBlockNumber = output.executionBlockNumber;
        }

        // Get the new period associated with the new head.
        uint256 newPeriod = getSyncCommitteePeriod(output.newHead);

        // Set the sync committee for the new period if it is not set.
        // This can happen if the light client was very behind and had a lot of updates.
        // Note: Only the latest sync committee is stored, not the intermediate ones from every update.
        if (syncCommittees[newPeriod] == bytes32(0)) {
            syncCommittees[newPeriod] = output.syncCommitteeHash;
            emit SyncCommitteeUpdated(newPeriod, output.syncCommitteeHash);
        }

        // Set the next sync committee if it is defined and not set.
        if (output.nextSyncCommitteeHash != bytes32(0)) {
            uint256 nextPeriod = newPeriod + 1;

            bytes32 _nextSyncCommitteeHash = syncCommittees[nextPeriod];
            if (_nextSyncCommitteeHash == bytes32(0)) {
                // If the next sync committee is not set, set it.
                syncCommittees[nextPeriod] = output.nextSyncCommitteeHash;
                emit SyncCommitteeUpdated(nextPeriod, output.nextSyncCommitteeHash);
            } else if (_nextSyncCommitteeHash != output.nextSyncCommitteeHash) {
                // If the next sync committee is non-zero, it should match the expected value.
                revert SyncCommitteeMismatch(_nextSyncCommitteeHash, output.nextSyncCommitteeHash);
            }
        }

        emit Updated(output.newHead, output.newHeader, output.executionStateRoot, output.executionBlockNumber);
    }

    /**
     * @notice Authorizes an upgrade to a new implementation.
     * @dev This function is required by the UUPS pattern and restricted to the contract owner.
     * @param newImplementation The address of the new implementation contract.
     */
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    /// @inheritdoc IEthereumLightClient
    function latestStateRoot() public view returns (bytes32) {
        return stateRoots[latestBlockNumber];
    }

    /// @inheritdoc IEthereumLightClient
    function getSyncCommitteePeriod(uint256 slot) public pure returns (uint256) {
        return slot / SLOTS_PER_PERIOD;
    }

    /// @inheritdoc IEthereumLightClient
    function getCurrentEpoch() public view returns (uint256) {
        return latestSlot / SLOTS_PER_EPOCH;
    }

    /**
     * @notice Pauses the contract, preventing updates and verifications
     * @dev Can only be called by the contract owner
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @notice Unpauses the contract, allowing updates and verifications
     * @dev Can only be called by the contract owner
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @notice Updates the verification key used for proof verification.
     * @dev Can only be called by the contract owner. See {IVkUpdatable-updateVk}.
     * @param newVk The new verification key to be set.
     */
    function updateVk(bytes32 newVk) external override onlyOwner {
        programVk = newVk;
        emit VkUpdated(newVk);
    }

    /**
     * @notice Returns the version of the EthereumISM contract
     * @return A string representing the semantic version
     */
    function version() external pure override returns (string memory) {
        return "v1.0.0";
    }
}
