// SPDX-License-Identifier: Apache-2.0
pragma solidity >=0.8.20;

import {IInterchainSecurityModule} from "hyperlane/interfaces/IInterchainSecurityModule.sol";
import {TREE_DEPTH} from "hyperlane/libs/Merkle.sol";
import {IVersioned} from "./IVersioned.sol";
import {IVkUpdatable} from "./IVkUpdatable.sol";

/**
 * @title IEvmISM
 * @notice Interface for a Hyperlane Interchain Security Module that verifies messages using SP1 ZK proofs
 *         of Merkle tree hook roots from EVM chains.
 * @dev This ISM verifies messages in two steps:
 *      1. Accept SP1 proofs of the source chain's Merkle tree hook roots via update()
 *      2. Validate Hyperlane messages against these roots via verify()
 */
interface IEvmISM is IInterchainSecurityModule, IVersioned, IVkUpdatable {
    /// @notice Thrown when an invalid address (e.g., zero address) is provided.
    error InvalidAddress();

    /// @notice Thrown when a state root does not match the expected value from the light client.
    error InvalidStateRoot();

    /**
     * @notice Emitted when a new Merkle tree root is verified and added to the valid roots set.
     * @param root The Merkle tree hook root that was verified.
     * @param blockNumber The source chain block number at which the root was proven.
     * @param stateRoot The source chain execution state root at the given block.
     */
    event Updated(bytes32 root, uint64 blockNumber, bytes32 stateRoot);

    /**
     * @notice Output structure from the Merkle tree verification circuit.
     * @dev This struct contains the data needed to validate a Merkle tree root against the source chain's state.
     * @param root The Merkle tree hook root from the Hyperlane contract.
     * @param stateRoot The source chain execution state root at the given block.
     * @param blockNumber The source chain block number where the Merkle root was proven.
     */
    struct CircuitOutput {
        bytes32 root;
        bytes32 stateRoot;
        uint64 blockNumber;
    }

    /**
     * @notice Merkle proof structure for verifying message inclusion.
     * @dev Contains the branch (sibling hashes) and index (leaf position) needed to verify
     *      a message is part of a Merkle tree.
     * @param branch Array of sibling hashes forming the Merkle proof path.
     * @param index The position of the message in the Merkle tree.
     */
    struct MerkleProof {
        bytes32[TREE_DEPTH] branch;
        uint64 index;
    }

    /**
     * @notice Updates the set of valid Merkle roots by verifying an SP1 proof.
     * @dev Verifies a ZK proof that attests to a valid Merkle tree hook root from the source EVM chain,
     *      validates the state root against the light client, and adds the root to the valid set.
     * @param proof The SP1 proof bytes generated by the Merkle tree circuit.
     * @param publicValues The ABI-encoded CircuitOutput containing the proof data.
     */
    function update(bytes calldata proof, bytes calldata publicValues) external;

    /**
     * @notice Verifies a Hyperlane message against a previously validated Merkle root.
     * @dev Decodes the Merkle proof from metadata, computes the message ID, calculates
     *      the Merkle root, and checks if it exists in the valid roots set.
     *      This function is called by the Hyperlane mailbox during message processing.
     * @param _metadata ABI-encoded MerkleProof containing the branch and index.
     * @param _message The Hyperlane message bytes to verify.
     * @return True if the message's Merkle root was previously verified, false otherwise.
     */
    function verify(bytes calldata _metadata, bytes calldata _message) external view returns (bool);
}
